#include "crypto.h"
#include <string.h>

#define DELTA 0x9E3779B9

static const uint8_t KEY_LARGE[4][16] = {
    "ilijnaiaayuxnixo",
    "tQ\xed|{\x5c\xd8r\x17O\xe0y\n\x15\xe4\xf5",
    "uohzoahzuhidkgna",
    "uileynimdpfnangr"
};

static const uint32_t KEY_SMALL[4] = {0xBABEFACE, 0xFEEDCAFE, 0xDEADBEEF, 0xABCD55AA};

static uint32_t MX(uint32_t sum, uint32_t y, uint32_t z, uint32_t p, uint32_t e, const uint32_t *k) {
    return ((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (k[(p & 3) ^ e] ^ z));
}

static void XXTEA_encode(uint32_t *v, int n, const uint32_t *k) {
    uint32_t y, z, sum;
    unsigned p, rounds, e;

    rounds = 6 + 52/n;
    sum = 0;
    z = v[n-1];
    do {
        sum += DELTA;
        e = (sum >> 2) & 3;
        for (p=0; p<n-1; p++) {
            y = v[p+1];
            z = v[p] += MX(sum, y, z, p, e, k);
        }
        y = v[0];
        z = v[n-1] += MX(sum, y, z, p, e, k);
    } while (--rounds);
}

static void XXTEA_decode(uint32_t *v, int n, const uint32_t *k) {
    uint32_t y, z, sum;
    unsigned p, rounds, e;

    rounds = 6 + 52/n;
    sum = rounds*DELTA;
    y = v[0];
    do {
        e = (sum >> 2) & 3;
        for (p=n-1; p>0; p--) {
            z = v[p-1];
            y = v[p] -= MX(sum, y, z, p, e, k);
        }
        z = v[n-1];
        y = v[0] -= MX(sum, y, z, p, e, k);
        sum -= DELTA;
    } while (--rounds);
}

void EncodeData(uint8_t *data, size_t length, uint8_t algorithm_version, uint8_t key_index) {
    if (algorithm_version == 1) {  // XXTEA
        XXTEA_encode((uint32_t*)data, length/4, (uint32_t*)KEY_LARGE[key_index]);
    } else if (algorithm_version == 2) {  // Simple XOR
        uint32_t key = KEY_SMALL[key_index];
        for (size_t i = 0; i < length; i += 4) {
            *(uint32_t*)(data + i) ^= key;
        }
    }
}

void DecodeData(uint8_t *data, size_t length, uint8_t algorithm_version, uint8_t key_index) {
    if (algorithm_version == 1) {  // XXTEA
        XXTEA_decode((uint32_t*)data, length/4, (uint32_t*)KEY_LARGE[key_index]);
    } else if (algorithm_version == 2) {  // Simple XOR
        EncodeData(data, length, algorithm_version, key_index);  // XOR is symmetric
    }
}
static const uint8_t CRC5_Lookup[256]=
{// CRC-5/BITMAIN = x5 + x2 + 1 POLY=0x5
0x00, 0x28, 0x50, 0x78, 0xA0, 0x88, 0xF0, 0xD8,
0x68, 0x40, 0x38, 0x10, 0xC8, 0xE0, 0x98, 0xB0,
0xD0, 0xF8, 0x80, 0xA8, 0x70, 0x58, 0x20, 0x08,
0xB8, 0x90, 0xE8, 0xC0, 0x18, 0x30, 0x48, 0x60,
0x88, 0xA0, 0xD8, 0xF0, 0x28, 0x00, 0x78, 0x50,
0xE0, 0xC8, 0xB0, 0x98, 0x40, 0x68, 0x10, 0x38,
0x58, 0x70, 0x08, 0x20, 0xF8, 0xD0, 0xA8, 0x80,
0x30, 0x18, 0x60, 0x48, 0x90, 0xB8, 0xC0, 0xE8,
0x38, 0x10, 0x68, 0x40, 0x98, 0xB0, 0xC8, 0xE0,
0x50, 0x78, 0x00, 0x28, 0xF0, 0xD8, 0xA0, 0x88,
0xE8, 0xC0, 0xB8, 0x90, 0x48, 0x60, 0x18, 0x30,
0x80, 0xA8, 0xD0, 0xF8, 0x20, 0x08, 0x70, 0x58,
0xB0, 0x98, 0xE0, 0xC8, 0x10, 0x38, 0x40, 0x68,
0xD8, 0xF0, 0x88, 0xA0, 0x78, 0x50, 0x28, 0x00,
0x60, 0x48, 0x30, 0x18, 0xC0, 0xE8, 0x90, 0xB8,
0x08, 0x20, 0x58, 0x70, 0xA8, 0x80, 0xF8, 0xD0,
0x70, 0x58, 0x20, 0x08, 0xD0, 0xF8, 0x80, 0xA8,
0x18, 0x30, 0x48, 0x60, 0xB8, 0x90, 0xE8, 0xC0,
0xA0, 0x88, 0xF0, 0xD8, 0x00, 0x28, 0x50, 0x78,
0xC8, 0xE0, 0x98, 0xB0, 0x68, 0x40, 0x38, 0x10,
0xF8, 0xD0, 0xA8, 0x80, 0x58, 0x70, 0x08, 0x20,
0x90, 0xB8, 0xC0, 0xE8, 0x30, 0x18, 0x60, 0x48,
0x28, 0x00, 0x78, 0x50, 0x88, 0xA0, 0xD8, 0xF0,
0x40, 0x68, 0x10, 0x38, 0xE0, 0xC8, 0xB0, 0x98,
0x48, 0x60, 0x18, 0x30, 0xE8, 0xC0, 0xB8, 0x90,
0x20, 0x08, 0x70, 0x58, 0x80, 0xA8, 0xD0, 0xF8,
0x98, 0xB0, 0xC8, 0xE0, 0x38, 0x10, 0x68, 0x40,
0xF0, 0xD8, 0xA0, 0x88, 0x50, 0x78, 0x00, 0x28,
0xC0, 0xE8, 0x90, 0xB8, 0x60, 0x48, 0x30, 0x18,
0xA8, 0x80, 0xF8, 0xD0, 0x08, 0x20, 0x58, 0x70,
0x10, 0x38, 0x40, 0x68, 0xB0, 0x98, 0xE0, 0xC8,
0x78, 0x50, 0x28, 0x00, 0xD8, 0xF0, 0x88, 0xA0,
};

static uint8_t crc5(uint8_t crc, const uint8_t *ptr, size_t bits)
{
	crc<<=3;
	int i;
	for (i=0; i< (bits>>3); i++)
		crc = CRC5_Lookup[crc ^ (*ptr++)];
	bits &= 7;
	if (bits)
	{
		crc = (crc << bits) ^ CRC5_Lookup[(crc ^ (*ptr++))>>(8-bits)];
	}
	return (crc>>3);
}
uint8_t CalculateCRC(/*uint8_t* crc, */const uint8_t *ptr, size_t bits){
    return crc5(0xFF, ptr, bits);
}
